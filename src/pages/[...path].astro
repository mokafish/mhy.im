---
import { collections } from "../content.config";
import magic from "../magic";
import { MagicTrie, PathNode } from "../friendship";
import type { MagicEntry } from "../friendship";
import { getCollection, render } from "astro:content";
import Page from "../layouts/Page.astro";
import MagicPage from "../layouts/MagicPage.astro";
import ErrorPage from "../layouts/ErrorPage.astro";
import MagicIndex from "../layouts/MagicIndex.astro";
// 1. Generate a new path for every collection entry

export async function getStaticPaths() {
    const catalog: MagicEntry[][] = [];
    const routes = [];
    for (let coll in collections) {
        // @ts-ignore
        catalog.push(await getCollection(coll));
        // const posts = await getCollection('blog');
    }

    const mt = new MagicTrie();
    for (let coll of catalog) {
        for (let entry of coll) {
            let path = magic.fmt.permalink(entry);
            let props = { entry, type: "entry", data: entry.data };
            mt.insert(path, props);
        }
    }

    for (let [path, pn] of mt.nmap) {
        // if (pn.isEnd) {
        //     if (pn.name == 'index') {
        //         path = pn.parent!.path
        //         pn.props.type = 'index'
        //         pn.props.list = pn.parent!.grouped() //.filter(p => p.name == 'index')
        //     }
        //
        //     routes.push({
        //         params: {path},
        //         props: pn.props,
        //     })
        // }else if (pn.name) {
        //     pn.children.has('index')
        // }

        if (!pn.name) continue;

        if(path.includes('index')){
            console.log(path);
        }

        if (!pn.hasChildren() && pn.name !== "index") {
            // if(path == '/docs/sub'){
            //     console.log('????? '+path);
            //     console.log('????? '+pn.name);
            //     console.log('????? '+pn.children);
            //     console.log('????? '+pn.children.size);
            // }
            routes.push({
                params: { path },
                props: pn.props,
            });
        } else if (pn.children.has("index")) {
            // console.log(path);

            pn.props = pn.children!.get("index")!.props;
            pn.props.type = "index";
            pn.props.list = pn.grouped();
            // console.log(pn);

            routes.push({
                params: { path },
                props: pn.props,
            });
        } else if (magic.autoindex(path)) {
            // pn.props = {
            //     type: "autoindex",
            //     data: { title: `${pn.name} (auto index)` },
            //     list: pn.grouped(),
            // };
            // routes.push({
            //     params: { path },
            //     props: pn.props,
            // });
        }
    }

    print_routes(routes);
    return routes;
}

export function print_routes(routes: any[]) {
    for (let r of routes) {
        let path = r.params.path as string;
        let type = r.props.type;
        let data = r.props.data;
        let has_entry = r.props.entry ? true : false;
        let has_list = r.props.list ? true : false;
        if (path == ("/docs/sub/index"))
            console.log({
                path,
                type,
                data,
                has_entry,
                has_list,
            });
    }
}
// 2. For your template, you can get the entry directly from the prop

interface Props {
    entry: MagicEntry;
    type: string;
    list: PathNode[][];
    // children: Map<string, PathNode>,
    // children: object,
}

const { entry, type, list } = Astro.props;

// console.log(children)
let Content;
if (entry) {
    // @ts-ignore
    let _r = await render(entry);
    // console.log(_r)
    Content = _r.Content;
}
---

<!--
{type === 'entry' &&
<MagicPage {...Astro.props}>
    {Content &&
            <Content/>}
</MagicPage>}
-->{
    type === "entry" ? (
        <MagicPage {...Astro.props}>{Content && <Content />}</MagicPage>
    ) : type === "index" ? (
        <MagicIndex {...Astro.props}>{Content && <Content />}</MagicIndex>
    ) : type === "autoindex" ? (
        <MagicIndex {...Astro.props} />
    ) : (
        <ErrorPage />
    )
}

<!--{()=>{-->

<!--    return-->
<!--    <ErrorPage/>-->
<!--    }}-->

<!--<Page title={entry.data?.title ?? entry.id} prose>-->
<!--    <Content/>-->
<!--    <p>-->
<!--        <em>{type}</em>-->
<!--    </p>-->

<!--    {type === 'index' && list[0].map((v) => (-->
<!--            <li>{v.name}</li>-->
<!--    ))}-->
<!--    {type === 'index' && list[1].map((v) => (-->
<!--            <li>{v.name}</li>-->
<!--    ))}-->

<!--{children.get('a')}-->

<!--{type === 'index' && (() => {-->
<!--    let list = []-->
<!--    for (let [k, v] of children) {-->
<!--        list.push(-->
<!--                <li>{k}</li>-->
<!--        )-->
<!--    }-->
<!--    return <ul>{list}</ul>-->
<!--})}-->

<!--{type === 'index' && children.map((v)=>(-->
<!--    <li key={v.id}>-->
<!--        <a>-->
<!--            {v}-->
<!--        </a>-->
<!--    </li>-->
<!--))}-->
<!--</Page>-->
